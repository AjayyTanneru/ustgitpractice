{
  "info": {
    "_postman_id": "8a55b44c-8e06-4d1f-a88a-90f12cb744fd",
    "name": "Xpath visualizer",
    "schema": "https://schema.getpostman.com/json/collection/v2.1.0/collection.json"
  },
  "item": [
    {
      "name": "New Request",
      "event": [
        {
          "listen": "test",
          "script": {
            "exec": [
              "// Tests: Parse response as XML-like and evaluate XPath //slide/item",
              "// Handles JSON->XML conversion fallback, and HTML/XML direct parsing",
              "",
              "(function () {",
              "  const xpathExpr = \"//slide/item\";",
              "",
              "  function toXmlFromJson(json) {",
              "    // Simple JSON->XML conversion (best-effort) for objects/arrays/primitives",
              "    function esc(str) {",
              "      return String(str)",
              "        .replace(/&/g, \"&amp;\")",
              "        .replace(/</g, \"&lt;\")",
              "        .replace(/>/g, \"&gt;\")",
              "        .replace(/\\\"/g, \"&quot;\")",
              "        .replace(/'/g, \"&apos;\");",
              "    }",
              "    function nodeFrom(key, value) {",
              "      const tag = key || \"item\";",
              "      if (value === null || value === undefined) {",
              "        return `<${tag}/>`;",
              "      }",
              "      if (Array.isArray(value)) {",
              "        return value.map((v, i) => nodeFrom(tag, v)).join(\"\");",
              "      }",
              "      switch (typeof value) {",
              "        case \"object\": {",
              "          const attrs = [];",
              "          const children = [];",
              "          Object.keys(value).forEach((k) => {",
              "            const v = value[k];",
              "            if (v === null || v === undefined) return;",
              "            // Heuristic: primitive values as attributes; objects/arrays as child nodes",
              "            if (typeof v === \"object\") {",
              "              children.push(nodeFrom(k, v));",
              "            } else {",
              "              attrs.push(`${k}=\"${esc(v)}\"`);",
              "            }",
              "          });",
              "          const attrStr = attrs.length ? \" \" + attrs.join(\" \") : \"\";",
              "          if (!children.length) return `<${tag}${attrStr}/>`;",
              "          return `<${tag}${attrStr}>${children.join(\"\")}</${tag}>`;",
              "        }",
              "        case \"string\":",
              "        case \"number\":",
              "        case \"boolean\":",
              "          return `<${tag}>${esc(value)}</${tag}>`;",
              "        default:",
              "          return `<${tag}/>`;",
              "      }",
              "    }",
              "    const root = typeof json === \"object\" && !Array.isArray(json) ? \"root\" : \"items\";",
              "    return `<?xml version=\"1.0\" encoding=\"UTF-8\"?><${root}>${nodeFrom(\"item\", json)}</${root}>`;",
              "  }",
              "",
              "  function parseAsDocument(raw, contentType) {",
              "    const isXml = /xml/i.test(contentType || \"\");",
              "    const isHtml = /html/i.test(contentType || \"\");",
              "    const isJson = /json/i.test(contentType || \"\");",
              "",
              "    let xmlText = raw;",
              "",
              "    if (isJson) {",
              "      try {",
              "        const json = pm.response.json();",
              "        xmlText = toXmlFromJson(json);",
              "      } catch (e) {",
              "        // If JSON parse fails, fall back to raw text and try XML/HTML directly",
              "      }",
              "    }",
              "",
              "    if (!isJson && !(isXml || isHtml)) {",
              "      // Try to detect JSON from body even if header misleading",
              "      try {",
              "        const json = JSON.parse(raw);",
              "        xmlText = toXmlFromJson(json);",
              "      } catch (e) {",
              "        // keep raw",
              "      }",
              "    }",
              "",
              "    // Use DOMParser for XML/HTML",
              "    const parser = new DOMParser();",
              "    const type = isHtml ? \"text/html\" : \"application/xml\";",
              "    let doc = parser.parseFromString(xmlText, type);",
              "",
              "    // Handle parsererror for XML",
              "    if (!isHtml && doc.getElementsByTagName(\"parsererror\").length) {",
              "      // Try parsing as HTML as a fallback",
              "      doc = parser.parseFromString(xmlText, \"text/html\");",
              "    }",
              "    return doc;",
              "  }",
              "",
              "  function evaluateXPath(doc, expr) {",
              "    // Prefer XPath if available in XML documents",
              "    try {",
              "      const iter = doc.evaluate(expr, doc, null, XPathResult.ORDERED_NODE_SNAPSHOT_TYPE, null);",
              "      const results = [];",
              "      for (let i = 0; i < iter.snapshotLength; i++) {",
              "        const node = iter.snapshotItem(i);",
              "        const text = (node && (node.textContent || \"\").trim()) || \"\";",
              "        const attrs = {};",
              "        if (node && node.attributes) {",
              "          for (let j = 0; j < node.attributes.length; j++) {",
              "            const a = node.attributes[j];",
              "            attrs[a.name] = a.value;",
              "          }",
              "        }",
              "        results.push({ text, attrs });",
              "      }",
              "      return results;",
              "    } catch (e) {",
              "      // If XPath evaluate isn't available (some HTML docs), attempt querySelectorAll fallback",
              "      const nodes = Array.from(doc.querySelectorAll(\"slide item\"));",
              "      return nodes.map((n) => ({",
              "        text: (n.textContent || \"\").trim(),",
              "        attrs: Array.from(n.attributes || []).reduce((acc, a) => { acc[a.name] = a.value; return acc; }, {})",
              "      }));",
              "    }",
              "  }",
              "",
              "  const raw = pm.response.text();",
              "  const contentType = pm.response.headers.get(\"Content-Type\") || \"\";",
              "  const doc = parseAsDocument(raw, contentType);",
              "  const matches = evaluateXPath(doc, xpathExpr);",
              "",
              "  // Tests summary and count assertion",
              "  pm.test(\"Found //slide/item nodes\", function () {",
              "    pm.expect(matches.length, `No nodes found for XPath ${xpathExpr}`).to.be.at.least(0);",
              "  });",
              "",
              "  // Add an info log with concise summary",
              "  pm.test(\"XPath summary\", function () {",
              "    const lines = matches.slice(0, 10).map((m, i) => {",
              "      const attrsStr = Object.keys(m.attrs).map(k => `${k}=\"${m.attrs[k]}\"`).join(\" \");",
              "      return `#${i + 1}: text=\"${m.text}\"${attrsStr ? ` attrs: ${attrsStr}` : \"\"}`;",
              "    });",
              "    console.log(`XPath ${xpathExpr} count=${matches.length}`);",
              "    pm.expect(true).to.be.true; // placeholder assertion so this test shows",
              "  });",
              "",
              "  // Visualizer table",
              "  const template = `",
              "    <style>",
              "      table { border-collapse: collapse; width: 100%; font-family: system-ui, Arial, sans-serif; }",
              "      th, td { border: 1px solid #ddd; padding: 6px 8px; font-size: 12px; }",
              "      th { background: #f6f8fa; text-align: left; }",
              "      caption { text-align: left; font-weight: 600; margin-bottom: 6px; }",
              "      code { background: #f2f2f2; padding: 1px 4px; }",
              "    </style>",
              "    <caption>XPath <code>//slide/item</code> results ({{count}})</caption>",
              "    <table>",
              "      <thead>",
              "        <tr>",
              "          <th>#</th>",
              "          <th>Text</th>",
              "          <th>Attributes</th>",
              "        </tr>",
              "      </thead>",
              "      <tbody>",
              "        {{#each rows}}",
              "          <tr>",
              "            <td>{{index}}</td>",
              "            <td>{{text}}</td>",
              "            <td>{{attributes}}</td>",
              "          </tr>",
              "        {{/each}}",
              "      </tbody>",
              "    </table>",
              "  `;",
              "",
              "  function createPayload() {",
              "    const rows = matches.map((m, i) => ({",
              "      index: i + 1,",
              "      text: m.text || \"\",",
              "      attributes: Object.keys(m.attrs).map(k => `${k}=${m.attrs[k]}`).join(\", \") || \"\",",
              "    }));",
              "    return { count: matches.length, rows };",
              "  }",
              "",
              "  pm.visualizer.set(template, createPayload());",
              "})();"
            ],
            "type": "text/javascript"
          }
        },
        {
          "listen": "prerequest",
          "script": {
            "exec": [
              ""
            ],
            "type": "text/javascript"
          }
        }
      ],
      "request": {
        "method": "GET",
        "header": [
          {
            "key": "Content-Type",
            "value": "application/json",
            "type": "text",
            "uuid": "a3bdeec4-7a30-40b9-bd0e-9d769a6f1270"
          }
        ],
        "url": {
          "raw": "http://httpbin.org/xml",
          "protocol": "http",
          "host": [
            "httpbin",
            "org"
          ],
          "path": [
            "xml"
          ]
        }
      }
    }
  ]
}